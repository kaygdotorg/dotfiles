#!/bin/sh

# helper functions from
# https://gitlab.com/kayg/sh-helpers

# same as -e
# exit immediately if command exits with a non-zero status
set -o errexit
# same as -u
# treat unset variables as error when substituting
set -o nounset

# check_if_installed(): a wrapper for `command -v` that silences the output and
# error streams.
#
# use:
#   check_if_installed cmd
check_if_installed() {
    command -v "${1}" 2>/dev/null 1>&2;
}

# check_if_installed_and_exit(): as the name implies, check if a program is installed. if
# it is, continue, otherwise exit with non-zero status.
#
# use:
#   check_if_installed_and_exit cmd
check_if_installed_and_exit() {
    if ! command -v "${1}" 2>/dev/null 1>&2; then
        printf '%s\n' "${1} is not installed. Please install ${1} to continue."
        exit 1
    fi
}

# run_cmd(): run commands while suppressing both the output and error streams
# and displaying a user-friendly "done" or "failed".
#
# use:
#   run_cmd cmd
run_cmd() {
    if [ -z "${1}" ]; then
        printf '%s' "No arguments provided. Exiting."
        exit 1
    fi

    # if ${logfile} is UNSET or EMPTY, set the value to the string "/dev/null"
    local output_stream="${logfile:-/dev/null}"
    local error_stream="${logfile:-/dev/null}"

    if ${@} 1>"${output_stream}" 2>"${error_stream}"; then
        printf " done\n"
    else
        printf " failed\n"
        exit 1
    fi
}

# run_cmd_with_log(): run commands while redirecting STDOUT and STDERR and
# displaying a user-friendly "done" or "failed" after the displayed message.
#
# use:
#   run_cmd logfile cmd
run_cmd_with_log() {
    if [ -z "${1}" ]; then
        printf '%s' "No arguments provided. Exiting."
        exit 1
    fi

    # get the absolute path of the first argument provided, i.e the file to log
    # stdout and stderr to
    logfile="$(realpath ${1})"

    # shift parameters by 1 to the right
    # $1=a $2=b $3=c
    #
    # become:
    #
    # $1=b $2=c $3=
    shift 1

    # reuse code in the run_cmd function
    run_cmd "${@}"
}

# status(): display a tick if the last command succeeded or a cross if the last
# command failed. this is done by cheching the exit code, which if non-zero
# indicates erroneous exit. basically, a drop-in replacement for `run_cmd()`
# where it cannot be used, for example: commands that need to be run with `sudo`
# or `doas`.
#
# use:
#   status
status() {
    if [ "${?}" = "0" ]; then
        printf " \u2714\n"
    else
        printf " \u274c\n"
        exit 1
    fi
}

# script local variables
script_path="$(dirname $(realpath ${0}))"

# dot
setup_dot() {
    printf '%s' "Adding dot to ${HOME}/.local/bin"
    run_cmd mkdir -p "${HOME}/.local/bin" && ln -sf "${script_path}/dot" "${HOME}/.local/bin"
}

update_dot() {
    printf '%s' "Updating dotfiles repository"
    run_cmd git -C "${script_path}" pull
}

# tmux
tmux_src="${script_path}/tmux"
tmux_dest="${HOME}/.config/tmux"

setup_tmux() {
    if [ -d "${tmux_dest}" ]; then
        printf '%s\n' "${tmux_dest} already exists. Remove it to reinstall: rm -rf ${tmux_dest}"
        exit 1
    fi

    printf '%s' "Cloning oh-my-tmux"
    run_cmd git clone "https://github.com/gpakosz/.tmux.git" "${tmux_dest}"

    printf '%s' "Linking tmux configuration"
    run_cmd ln -sf "${tmux_dest}/.tmux.conf" "${HOME}" && ln -sf "${tmux_src}/.tmux.conf.local" "${HOME}/.tmux.conf.local"

    printf '%s' "Installing tpm (tmux plugin manager)"
    if [ -d "${HOME}/.tmux/plugins/tpm" ]; then
        printf ' skipped (already exists: %s)\n' "${HOME}/.tmux/plugins/tpm"
    else
        run_cmd mkdir -p "${HOME}/.tmux/plugins" && git clone "https://github.com/tmux-plugins/tpm" "${HOME}/.tmux/plugins/tpm"
    fi
}

update_tmux() {
    printf '%s' "Updating oh-my-tmux repo"
    run_cmd git --git-dir="${tmux_dest}/.git" --work-tree="${tmux_dest}" pull
}

# zsh
zsh_src="${script_path}/zsh/.config/zsh"
zsh_dest_zsh="${HOME}/.config/zsh"
zsh_dest_plugins="${HOME}/.config/zsh/plugins"
zsh_plugins="
    https://github.com/zsh-users/zsh-autosuggestions
    https://github.com/zsh-users/zsh-completions
    https://github.com/zsh-users/zsh-history-substring-search
    https://github.com/zsh-users/zsh-syntax-highlighting
"

setup_zsh() {
    if [ -d "${zsh_dest_zsh}" ]; then
       printf '%s' "${zsh_dest_zsh} exists, which indicates a previous installation. Please remove this directory and run the setup again."
       exit 1
    fi

    # copy zshenv to /etc/zsh
    printf '%s' "Linking zshenv to ${HOME}"
    run_cmd ln -sf "${script_path}/zsh/.zshenv" "${HOME}"

    # create plugin and cache directories
    printf '%s' "Creating plugin and cache directories"
    run_cmd mkdir -p "${zsh_dest_plugins}" "${zsh_dest_zsh}/cache"

    # install plugins for zsh
    printf '%s\n' 'Setting up plugins for ZSH'
    for plugin in ${zsh_plugins}; do
        printf '%s' "  Cloning ${plugin}"
        run_cmd git -C "${zsh_dest_plugins}" clone "${plugin}"
    done

    # install oh-my-posh
    printf '%s' 'Installing oh-my-posh'
    curl -s https://ohmyposh.dev/install.sh | bash -s -- -d "${HOME}/.local/bin" 1>/dev/null 2>/dev/null
    status

    # linking configuration
    printf '%s' 'Linking personal configuration'
    run_cmd ln -sf "${zsh_src}/.zshrc" "${zsh_dest_zsh}" && ln -sf "${zsh_src}/omp.yaml" "${zsh_dest_zsh}"
}

update_zsh() {
    printf '%s\n' 'Updating plugins'
    for plugin in "${zsh_dest_plugins}"/*; do
        printf '%s' "  Updating $(basename "${plugin}")"
        run_cmd git -C "${plugin}" pull
    done

    printf '%s' 'Updating oh-my-posh'
    curl -s https://ohmyposh.dev/install.sh | bash -s -- -d "${HOME}/.local/bin" 1>/dev/null 2>/dev/null
    status
}

# atuin
atuin_src="${script_path}/atuin/.config/atuin"

setup_atuin() {
    if [ -d "${HOME}/.atuin" ]; then
        printf '%s\n' "${HOME}/.atuin already exists. Run 'dot update atuin' to update."
        exit 1
    fi

    printf '%s' 'Installing atuin'
    curl --proto '=https' --tlsv1.2 -LsSf https://setup.atuin.sh | sh 1>/dev/null 2>/dev/null
    status

    # symlink to ~/.local/bin so atuin is available in tmux popups
    # (tmux global PATH doesn't include ~/.atuin/bin)
    printf '%s' 'Linking atuin to ~/.local/bin'
    run_cmd ln -sf "${HOME}/.atuin/bin/atuin" "${HOME}/.local/bin/atuin"

    printf '%s' 'Linking atuin configuration'
    run_cmd mkdir -p "${HOME}/.config/atuin" && ln -sf "${atuin_src}/config.toml" "${HOME}/.config/atuin/config.toml"

    printf '%s\n' 'Run the following to complete setup:'
    printf '%s\n' '  exec zsh'
    printf '%s\n' '  atuin register -u <USERNAME> -e <EMAIL>  (or: atuin login -u <USERNAME>)'
    printf '%s\n' '  atuin import auto'
    printf '%s\n' '  atuin sync'
}

update_atuin() {
    printf '%s' 'Updating atuin'
    curl --proto '=https' --tlsv1.2 -LsSf https://setup.atuin.sh | sh 1>/dev/null 2>/dev/null
    status
}

# ssh
ssh_src="${script_path}/.ssh"
ssh_dest="${HOME}/.ssh"

setup_ssh() {
    # create ~/.ssh directory with correct permissions
    printf '%s' "Creating ${ssh_dest} directory"
    run_cmd mkdir -p "${ssh_dest}" && chmod 700 "${ssh_dest}"

    # link ssh config
    if [ -f "${ssh_src}/config" ]; then
        printf '%s' "Linking SSH config"
        run_cmd ln -sf "${ssh_src}/config" "${ssh_dest}/config" && chmod 600 "${ssh_dest}/config"
    else
        printf '%s\n' "Warning: ${ssh_src}/config does not exist. Skipping config setup."
    fi

    printf '%s\n' "SSH setup complete. Make sure your SSH keys are in ${ssh_dest}/"
}

main() {
    # check if running in termux
    if check_if_installed termux-setup-storage; then
        termux=1
    fi


    case "${2}" in
        dot|atuin) ;;
        *) check_if_installed_and_exit "${2}" ;;
    esac
    ${1}_${2}
}

main "${@}"

exit 0
